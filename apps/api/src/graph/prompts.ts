import { db } from '../db/index.js';
import { prompts } from '../db/schema.js';
import { eq, and, desc, isNull } from 'drizzle-orm';

const DEFAULT_PROMPTS: Record<string, string> = {
  research: `Ты — исследовательский ассистент для технологического блога. Проведи глубокое исследование указанной темы.

Тема: {topic}
URL для анализа:
{inputUrls}
Ключевые слова: {keywords}

Задачи:
1. Собери ключевые факты, цифры и актуальные данные по теме
2. Определи основные тенденции и экспертные мнения
3. Найди технические детали, спецификации и сравнительные характеристики
4. Выяви потенциальные проблемы и их решения
5. Подбери примеры применения и практические кейсы

Выведи структурированный отчёт на русском языке с подзаголовками для каждого раздела исследования. Используй конкретные цифры и факты, избегай общих фраз.`,

  outline: `Создай детальный план статьи для технологического блога на русском языке.

Тема: {topic}

Результаты исследования:
{research}

Контекст стиля (из эталонных статей):
{ragContext}

Требования к плану:
1. Заголовок H1 — цепляющий, информативный, содержит ключевые слова
2. {formatInstructions}
3. Для каждой секции укажи ключевые тезисы и данные из исследования
4. Предусмотри введение и заключение

Формат вывода — markdown, где каждая секция обозначена через ## заголовок, после которого идёт описание.`,

  write_section: `Напиши секцию статьи для технологического блога на русском языке.

КРИТИЧНО — ОГРАНИЧЕНИЕ ОБЪЁМА: {sectionInstructions}

Заголовок секции: {sectionTitle}
Описание секции: {sectionDescription}
Полный план статьи: {outline}
Данные исследования: {research}
Контекст стиля (из эталонных статей): {ragContext}
Ссылки компании для органичной интеграции: {companyLinks}

Требования:
- Профессиональный, но доступный тон — как для опытного IT-специалиста
- Конкретика: цифры, характеристики, сравнения, примеры
- Активная форма глаголов, без канцелярита
- Логичные переходы между абзацами
- Технические термины с пояснениями, где это нужно
- Если релевантно, органично вставь ссылки компании в текст

Выведи только текст секции в формате markdown (без повторения заголовка H2).`,

  edit_polish: `Отредактируй и доработай черновик статьи для технологического блога на русском языке.

КРИТИЧНО — ТРЕБОВАНИЯ К ФОРМАТУ: {editInstructions}

Черновик:
{draft}

Контекст стиля (из эталонных статей):
{ragContext}

Целевые ключевые слова для SEO: {keywords}

Задачи редактуры:
1. Проверь логику изложения и связность между секциями
2. Оптимизируй для SEO: ключевые слова в заголовках и первых абзацах
3. Выровняй тон: профессиональный, живой, без канцелярита — как в эталонных статьях
4. Проверь техническую точность формулировок
5. Добавь плавные переходы между секциями
6. Убери повторы, длинноты, общие фразы

ВАЖНО: Выведи ТОЛЬКО текст статьи в формате markdown. БЕЗ вступительных фраз, БЕЗ комментариев от себя, БЕЗ строк "Meta Description", БЕЗ пояснений что ты изменил. Начни сразу с заголовка H1 статьи (# Заголовок). Сохрани всю структуру H1/H2.`,

  image_prompt: `Сгенерируй один промпт для заглавного изображения технологической статьи.

Заголовок статьи: {title}
Краткое содержание: {summary}

Промпт должен описывать одно изображение, передающее суть и основную идею статьи.
Промпт на английском языке.

ОБЯЗАТЕЛЬНЫЕ требования к стилю:
- Минималистичный tech-style: чистые линии, геометрия, схемы, устройства, интерфейсы
- Яркие насыщенные цвета на тёмном или градиентном фоне
- БЕЗ людей, БЕЗ лиц, БЕЗ фигур людей, БЕЗ совещаний, БЕЗ офисных сцен
- БЕЗ текста на изображении
- Формат: hero image 16:9, подходит как обложка статьи

Выведи ТОЛЬКО один промпт, без нумерации и пояснений.`,
};

export const getPromptTemplate = async (stage: string, contentType?: string): Promise<string> => {
  try {
    // 1. Try format-specific prompt
    if (contentType) {
      const [specific] = await db.select()
        .from(prompts)
        .where(and(
          eq(prompts.stage, stage),
          eq(prompts.contentType, contentType as any),
          eq(prompts.isActive, true),
        ))
        .orderBy(desc(prompts.version))
        .limit(1);
      if (specific) return specific.template;
    }

    // 2. Fallback to universal prompt (contentType IS NULL)
    const [universal] = await db.select()
      .from(prompts)
      .where(and(
        eq(prompts.stage, stage),
        isNull(prompts.contentType),
        eq(prompts.isActive, true),
      ))
      .orderBy(desc(prompts.version))
      .limit(1);
    if (universal) return universal.template;
  } catch {
    // DB not available, use defaults
  }

  // 3. Fallback to hardcoded defaults
  return DEFAULT_PROMPTS[stage] || '';
};
